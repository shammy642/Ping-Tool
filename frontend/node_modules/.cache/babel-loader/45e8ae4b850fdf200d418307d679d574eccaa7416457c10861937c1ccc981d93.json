{"ast":null,"code":"\"use strict\";\n\nvar __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n    return t;\n  };\n  return __assign.apply(this, arguments);\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.attachListeners = void 0;\nvar socket_io_1 = require(\"./socket-io\");\nvar constants_1 = require(\"./constants\");\nvar util_1 = require(\"./util\");\nvar bindMessageHandler = function (webSocketInstance, optionsRef, setLastMessage) {\n  webSocketInstance.onmessage = function (message) {\n    optionsRef.current.onMessage && optionsRef.current.onMessage(message);\n    if (typeof optionsRef.current.filter === 'function' && optionsRef.current.filter(message) !== true) {\n      return;\n    }\n    setLastMessage(message);\n  };\n};\nvar bindOpenHandler = function (webSocketInstance, optionsRef, setReadyState, reconnectCount) {\n  webSocketInstance.onopen = function (event) {\n    optionsRef.current.onOpen && optionsRef.current.onOpen(event);\n    reconnectCount.current = 0;\n    setReadyState(constants_1.ReadyState.OPEN);\n  };\n};\nvar bindCloseHandler = function (webSocketInstance, optionsRef, setReadyState, reconnect, reconnectCount) {\n  if (constants_1.isEventSourceSupported && webSocketInstance instanceof EventSource) {\n    return function () {};\n  }\n  util_1.assertIsWebSocket(webSocketInstance);\n  var reconnectTimeout;\n  webSocketInstance.onclose = function (event) {\n    var _a, _b;\n    optionsRef.current.onClose && optionsRef.current.onClose(event);\n    setReadyState(constants_1.ReadyState.CLOSED);\n    if (optionsRef.current.shouldReconnect && optionsRef.current.shouldReconnect(event)) {\n      var reconnectAttempts = (_a = optionsRef.current.reconnectAttempts) !== null && _a !== void 0 ? _a : constants_1.DEFAULT_RECONNECT_LIMIT;\n      if (reconnectCount.current < reconnectAttempts) {\n        reconnectTimeout = window.setTimeout(function () {\n          reconnectCount.current++;\n          reconnect();\n        }, (_b = optionsRef.current.reconnectInterval) !== null && _b !== void 0 ? _b : constants_1.DEFAULT_RECONNECT_INTERVAL_MS);\n      } else {\n        optionsRef.current.onReconnectStop && optionsRef.current.onReconnectStop(reconnectAttempts);\n        console.warn(\"Max reconnect attempts of \" + reconnectAttempts + \" exceeded\");\n      }\n    }\n  };\n  return function () {\n    return reconnectTimeout && window.clearTimeout(reconnectTimeout);\n  };\n};\nvar bindErrorHandler = function (webSocketInstance, optionsRef, setReadyState, reconnect, reconnectCount) {\n  var reconnectTimeout;\n  webSocketInstance.onerror = function (error) {\n    var _a, _b;\n    optionsRef.current.onError && optionsRef.current.onError(error);\n    if (constants_1.isEventSourceSupported && webSocketInstance instanceof EventSource) {\n      optionsRef.current.onClose && optionsRef.current.onClose(__assign(__assign({}, error), {\n        code: 1006,\n        reason: \"An error occurred with the EventSource: \" + error,\n        wasClean: false\n      }));\n      setReadyState(constants_1.ReadyState.CLOSED);\n      webSocketInstance.close();\n    }\n    if (optionsRef.current.retryOnError) {\n      if (reconnectCount.current < ((_a = optionsRef.current.reconnectAttempts) !== null && _a !== void 0 ? _a : constants_1.DEFAULT_RECONNECT_LIMIT)) {\n        reconnectTimeout = window.setTimeout(function () {\n          reconnectCount.current++;\n          reconnect();\n        }, (_b = optionsRef.current.reconnectInterval) !== null && _b !== void 0 ? _b : constants_1.DEFAULT_RECONNECT_INTERVAL_MS);\n      } else {\n        optionsRef.current.onReconnectStop && optionsRef.current.onReconnectStop(optionsRef.current.reconnectAttempts);\n        console.warn(\"Max reconnect attempts of \" + optionsRef.current.reconnectAttempts + \" exceeded\");\n      }\n    }\n  };\n  return function () {\n    return reconnectTimeout && window.clearTimeout(reconnectTimeout);\n  };\n};\nexports.attachListeners = function (webSocketInstance, setters, optionsRef, reconnect, reconnectCount, sendMessage) {\n  var setLastMessage = setters.setLastMessage,\n    setReadyState = setters.setReadyState;\n  var interval;\n  var cancelReconnectOnClose;\n  var cancelReconnectOnError;\n  if (optionsRef.current.fromSocketIO) {\n    interval = socket_io_1.setUpSocketIOPing(sendMessage);\n  }\n  bindMessageHandler(webSocketInstance, optionsRef, setLastMessage);\n  bindOpenHandler(webSocketInstance, optionsRef, setReadyState, reconnectCount);\n  cancelReconnectOnClose = bindCloseHandler(webSocketInstance, optionsRef, setReadyState, reconnect, reconnectCount);\n  cancelReconnectOnError = bindErrorHandler(webSocketInstance, optionsRef, setReadyState, reconnect, reconnectCount);\n  return function () {\n    setReadyState(constants_1.ReadyState.CLOSING);\n    cancelReconnectOnClose();\n    cancelReconnectOnError();\n    webSocketInstance.close();\n    if (interval) clearInterval(interval);\n  };\n};","map":{"version":3,"names":["socket_io_1","require","constants_1","util_1","bindMessageHandler","webSocketInstance","optionsRef","setLastMessage","onmessage","message","current","onMessage","filter","bindOpenHandler","setReadyState","reconnectCount","onopen","event","onOpen","ReadyState","OPEN","bindCloseHandler","reconnect","isEventSourceSupported","EventSource","assertIsWebSocket","reconnectTimeout","onclose","onClose","CLOSED","shouldReconnect","reconnectAttempts","_a","DEFAULT_RECONNECT_LIMIT","window","setTimeout","_b","reconnectInterval","DEFAULT_RECONNECT_INTERVAL_MS","onReconnectStop","console","warn","clearTimeout","bindErrorHandler","onerror","error","onError","__assign","code","reason","wasClean","close","retryOnError","exports","attachListeners","setters","sendMessage","interval","cancelReconnectOnClose","cancelReconnectOnError","fromSocketIO","setUpSocketIOPing","CLOSING","clearInterval"],"sources":["/Users/samuelhoile/Documents/Visual Studio Code Projects/Ping Tool/frontend/node_modules/react-use-websocket/src/lib/attach-listener.ts"],"sourcesContent":["import { MutableRefObject } from 'react';\nimport { setUpSocketIOPing } from './socket-io';\nimport {\n  DEFAULT_RECONNECT_LIMIT,\n  DEFAULT_RECONNECT_INTERVAL_MS,\n  ReadyState,\n  isEventSourceSupported,\n} from './constants';\nimport { Options, SendMessage, WebSocketLike } from './types';\nimport { assertIsWebSocket } from './util';\n\nexport interface Setters {\n  setLastMessage: (message: WebSocketEventMap['message']) => void;\n  setReadyState: (readyState: ReadyState) => void;\n}\n\nconst bindMessageHandler = (\n  webSocketInstance: WebSocketLike,\n  optionsRef: MutableRefObject<Options>,\n  setLastMessage: Setters['setLastMessage'],\n) => {\n  webSocketInstance.onmessage = (message: WebSocketEventMap['message']) => {\n    optionsRef.current.onMessage && optionsRef.current.onMessage(message);\n    if (typeof optionsRef.current.filter === 'function' && optionsRef.current.filter(message) !== true) {\n      return;\n    }\n    setLastMessage(message);\n  };\n};\n\nconst bindOpenHandler = (\n  webSocketInstance: WebSocketLike,\n  optionsRef: MutableRefObject<Options>,\n  setReadyState: Setters['setReadyState'],\n  reconnectCount: MutableRefObject<number>,\n) => {\n  webSocketInstance.onopen = (event: WebSocketEventMap['open']) => {\n    optionsRef.current.onOpen && optionsRef.current.onOpen(event);\n    reconnectCount.current = 0;\n    setReadyState(ReadyState.OPEN);\n  };\n};\n\nconst bindCloseHandler = (\n  webSocketInstance: WebSocketLike,\n  optionsRef: MutableRefObject<Options>,\n  setReadyState: Setters['setReadyState'],\n  reconnect: () => void,\n  reconnectCount: MutableRefObject<number>,\n) => {\n  if (isEventSourceSupported && webSocketInstance instanceof EventSource) {\n    return () => {};\n  }\n  assertIsWebSocket(webSocketInstance);\n  let reconnectTimeout: number;\n\n  webSocketInstance.onclose = (event: WebSocketEventMap['close']) => {\n    optionsRef.current.onClose && optionsRef.current.onClose(event);\n    setReadyState(ReadyState.CLOSED);\n    if (optionsRef.current.shouldReconnect && optionsRef.current.shouldReconnect(event)) {\n      const reconnectAttempts = optionsRef.current.reconnectAttempts ?? DEFAULT_RECONNECT_LIMIT;\n      if (reconnectCount.current < reconnectAttempts) {\n        reconnectTimeout = window.setTimeout(() => {\n          reconnectCount.current++;\n          reconnect();\n        }, optionsRef.current.reconnectInterval ?? DEFAULT_RECONNECT_INTERVAL_MS);\n      } else {\n        optionsRef.current.onReconnectStop && optionsRef.current.onReconnectStop(reconnectAttempts);\n        console.warn(`Max reconnect attempts of ${reconnectAttempts} exceeded`);\n      }\n    }\n  };\n\n  return () => reconnectTimeout && window.clearTimeout(reconnectTimeout);\n};\n\nconst bindErrorHandler = (\n  webSocketInstance: WebSocketLike,\n  optionsRef: MutableRefObject<Options>,\n  setReadyState: Setters['setReadyState'],\n  reconnect: () => void,\n  reconnectCount: MutableRefObject<number>,\n) => {\n  let reconnectTimeout: number;\n\n  webSocketInstance.onerror = (error: WebSocketEventMap['error']) => {\n    optionsRef.current.onError && optionsRef.current.onError(error);\n    if (isEventSourceSupported && webSocketInstance instanceof EventSource) {\n      optionsRef.current.onClose && optionsRef.current.onClose({\n        ...error,\n        code: 1006,\n        reason: `An error occurred with the EventSource: ${error}`,\n        wasClean: false,\n      });\n\n      setReadyState(ReadyState.CLOSED);\n      webSocketInstance.close();\n    }\n    \n    if (optionsRef.current.retryOnError) {\n      if (reconnectCount.current < (optionsRef.current.reconnectAttempts ?? DEFAULT_RECONNECT_LIMIT)) {\n        reconnectTimeout = window.setTimeout(() => {\n          reconnectCount.current++;\n          reconnect();\n        }, optionsRef.current.reconnectInterval ?? DEFAULT_RECONNECT_INTERVAL_MS);\n      } else {\n        optionsRef.current.onReconnectStop && optionsRef.current.onReconnectStop(optionsRef.current.reconnectAttempts as number);\n        console.warn(`Max reconnect attempts of ${optionsRef.current.reconnectAttempts} exceeded`);\n      }\n    }\n  };\n\n  return () => reconnectTimeout && window.clearTimeout(reconnectTimeout);\n};\n\nexport const attachListeners = (\n    webSocketInstance: WebSocketLike,\n    setters: Setters,\n    optionsRef: MutableRefObject<Options>,\n    reconnect: () => void,\n    reconnectCount: MutableRefObject<number>,\n    sendMessage: SendMessage,\n  ): (() => void) => {\n  const { setLastMessage, setReadyState } = setters;\n\n  let interval: number;\n  let cancelReconnectOnClose: () => void;\n  let cancelReconnectOnError: () => void;\n\n  if (optionsRef.current.fromSocketIO) {\n    interval = setUpSocketIOPing(sendMessage);\n  }\n\n  bindMessageHandler(\n    webSocketInstance,\n    optionsRef,\n    setLastMessage,\n  );\n\n  bindOpenHandler(\n    webSocketInstance,\n    optionsRef,\n    setReadyState,\n    reconnectCount,\n  );\n\n  cancelReconnectOnClose = bindCloseHandler(\n    webSocketInstance,\n    optionsRef,\n    setReadyState,\n    reconnect,\n    reconnectCount,\n  );\n\n  cancelReconnectOnError = bindErrorHandler(\n    webSocketInstance,\n    optionsRef,\n    setReadyState,\n    reconnect,\n    reconnectCount,\n  );\n\n  return () => {\n    setReadyState(ReadyState.CLOSING);\n    cancelReconnectOnClose();\n    cancelReconnectOnError();\n    webSocketInstance.close();\n    if (interval) clearInterval(interval);\n  };\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}